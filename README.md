## Server.CS
### 지식공유자 : [Rookiss](https://www.inflearn.com/instructors/230375/courses)
## 교육 일기 
### 1020_멀티 쓰레드 개론, 쓰레드 생성, 컴파일러의 최적화
서버를 구축하기 위해 필요한 **멀티 쓰레드** 지식과 쓰레드를 코드상에서 어떻게 사용하는지 기본적인 방법에 대해 배웠고 컴파일러가 **Release**상태에서 코드를 실행할 때 어떤 최적화가 일어나는지 그리고 그 최적화 구간에 쓰레드의 변화에 대해 배웠습니다. 또 **Volatile** 문법에 대해서도 간략하게나마 배웠습니다. 멀티 쓰레드는 **Heap 영역을 공유하며 각자 쓰레드마다 Stack 영역**을 보유하고 있습니다.
### 1021_캐시 이론, 메모리 배리어, InterLocked, Lock 기초, DeadLock, Lock 구현 이론
코어에 내장되어있는 캐시에 대해 알아봤으며 캐시가 어떻게 작동하는지 또 어떤 특성이 있는지 배웠습니다. **메모리 배리어**는 **코드 재배치를 억제**하고 *(컴파일러 최적화시 코드의 순서가 뒤바뀔 가능성이 있음)* *가시성*을 보장한다는것을 배웠습니다. **Interlocked** 클래스를 이용해 값을 증가시키거나 감소시킬 때 생기는 세 단계를 단일 작업으로 처리시켜줍니다. **Atomic(원자성)** 이라고도 합니다. 또 Lock 키워드에 대해 배웠습니다. **Monitor.Enter, Exit**와 비슷한 기능을 하되 좀 더 간략하게 변화된 형태입니다. 매개변수로는 object를 받으며 문자 그대로 자물쇠의 역할을 합니다. 어떤 경우에는 **DeadLock** 현상을 일으키며 DeadLock은 **상호 배제(Mutual Exclusion)** 가 일어날 경우에 나타나는것이 일반적입니다. Lock 구현 이론에서는 Lock을 어떤식으로 배치하는지에 대해 간략하게 배웠습니다. 
### 1129_SpinLock
*CAS(Compare-And-Swap)* 를 이용하는 Lock 구현 방식이며 *Interlocked.CompareExchange(ref original, desired, expected)* 함수를 이용해서 구현합니다.  
### 0117_SpinLock 복습, Context Switching, AutoResetEvent, ManualResetEvent, Mutex, ReaderWriteLock
오랜만에 다시 강의를 듣게 되서 전에 들었던 강의인 SpinLock 강의를 들으면서 마음을 다잡았고 Context Switching이 어떤 것인지 또 어떤 종류로 나뉘어서 활용하게 되는지 배웠습니다. AutoResetEvent와 ManualResetEvent, Mutex, ReaderWriteLock 등 바로 설명하기 어려운 부분은 따로 정보를 더 찾아봐야 할 것같습니다.	
### 0117_ReaderWriteLock 연습, TLS(Thread Local Storage), Parallel 라이브러리
*ReaderWriteLock* 클래스가 어떤식으로 작동하는지 내부 함수를 구현하는 연습을 했습니다. *TLS(Thread-Local-Storage)* 이 어떤식으로 사용되는지, 주로 어떤 함수 및 프로퍼티를 이용하는지 배웠습니다. 전역 변수(Heap 영역)을 가져와 지역 변수(Stack 영역)처럼 이용, *Parallel.Invoke* 함수를 간략하게 써봤습니다. Task 클래스를 대신해서 간단하게 테스트 할 때 쓰면 좋을 것 같습니다. 
### 0118_네트워크 기초 이론, 통신 모델, 소켓 프로그래밍  
전체적으로 단번에 이해하기 힘든 강의였기에 코드를 따라 작성하고 되짚어가며 공부했습니다. 
### 0120_Listener, Session 1  
이해가 잘 안되는 부분이 많았습니다. 전에 작성한 소켓 프로그래밍 자료를 비동기 방식으로 재배치하는 작업을 했습니다. *SocketAsyncEventArgs.Completed* 를 이용했습니다.
### 0120_Session 2~4, Connector, TCP vs UDP 
전 강의에서 하던 세션 작업을 이어서 하였고 클라이언트 접속 시 발생하는 Connector 부분 인터페이스를 Listener와 거의 동일하게 맞춰주었습니다. 그리고 *TCP(Transmission Control Protocol)* 와 *UDP(User Datagram Protocol)* 가 어떤 의미인지 어떤 상황에 사용하는지 두 가지방법의 장점과 단점에 대해서 간략하게 배웠습니다. 먼저 TCP는 패킷을 전달하는데에 있어서 안전을 보장하지만 모든 부분을 검증하기 때문에 속도가 느리고 반대로 UDP 같은 경우에는 안전을 보장하지 않는 대신 속도가 TCP에 비해 빠릅니다. 또한 UDP를 TCP처럼 신뢰성을 가질 수 있도록 만든것이 *RUDP(Reliable UDP)* 입니다.  
### 0122_RecvBuffer, SendBuffer, PacketSession  
*RecieveBuffer*를 일일이 작성하지 않고 따로 클래스를 만들어 관리하도록 했고 *SendBuffer* 또한 동일하게 개편했습니다. SendBuffer의 경우 멀티쓰레드 환경에서 사용하기 때문에 이전에 배운 **ThreadLocal** 클래스를 이용해서 Stack 영역에서 활용할 수 있도록 처리했습니다. 
### 0122_패킷 직렬화 1~2 
패킷을 좀 더 효율적으로 관리하기 위해서 PacketSession을 만들었습니다. 패킷을 통신할 때 **BitConverter**를 이용했습니다. BitConverter.TryWriteBytes() 함수를 이용해서 패킷 직렬화와 역직렬화를 수행했습니다. 
### 0124_UTF-8,16 패킷 직렬화 3~4
문자열을 패킷으로 직렬화 시킬 때 어떤 유형을 선택해서 할 것인지에 대해 배웠습니다. 기본적으로 C# 에서의 문자열은 UTF-16로 작성되기 때문에 Encoding.Unicode 클래스를 이용했습니다. UTF-8은 영문에 1byte를 부여하고 한글에 3byte를 할당합니다. UTF-16은 영문과 한글에 또는 BMP에 포함되어있는 문자들에 한해서 2byte 씩 할당합니다. 예외적으로 BMP 이후 문자에는 4byte 씩 할당합니다. 또 List를 패킷으로 직렬화 시키는 방법도 배웠습니다. 
### 0126_패킷 자동화 1~3
이전에 작성한 패킷 직렬화 코드를 자동화시키는 **PacketGenerator** 클래스를 만들었습니다. **Xml**을 이용한 ServerSession 과 ClientSession 간의 패킷 송수신을 시도했습니다. 이전에 작성한 코드를 따로 포맷시켜서 사용했습니다. 
### 0130_패킷 자동화 4~6
이번에는 처음 사용해보는 batch 파일을 만들어 미리 포맷해둔 GenPackets.cs 및 PacketManager.cs파일을 Copy하고 뿌려주었습니다. 그리고 IPacket 인터페이스를 만들어 좀 더 직관적으로 사용할 수 있게끔 하였으며 서버에서 처음으로 Singleton 디자인 패턴을 이용해 PacketManager를 만들어 자동화에 사용했습니다.
### 0131_채팅 테스트 1~2
이전까지 만들어놓은 Session이 실제 상황에서 정상적으로 작동하는지 테스트하기 위하여 간단한 채팅 테스트를 했습니다. 
### 0201_Command 패턴, JobQueue 1~2 
Command 패턴이란 클라이언트의 요청을 캡슐화해서 실행하도록 합니다. 해당 패턴을 이용해 서버의 패킷 전송을 JobQueue를 만들었습니다. 채팅 테스트에서 쓰인 GameRoom의 기능들은 이제 바로 실행되지 않고 JobQueue에 넣어 한 쓰레드당 한 번씩 순서대로 실행되게끔 했습니다. 이로 인해 무차별적으로 늘어나던 작업자 쓰레드를 눈에 띄게 줄였습니다.
### 0202_패킷 모아보내기
이전 시간까지는 패킷을 하나씩 송수신했었는데 그렇게 되면 시간복잡도가 O(N^2)이 되기때문에 하나의 패킷을 전 유저에게 보낼 때 한 번씩 송신하는게 아니라 만약에 유저가 500명이 있다고 친다면 한 패킷을 500명분을 모아서 한 번에 보내주는 식으로 구현했습니다. 이렇게 하면 시간복잡도는 O(N)이 되며 한층 낮출 수 있었습니다.  
### 0203_JobTimer
GameRoom과 같은 컨텐츠단위의 Job(일)을 효율적으로 관리하기 위해 JobTimer를 만들었습니다. JobTimer는 Job들 중 가장 빨리 실행시켜야하는 것을 우선순위로 두고 시간이 지나면 Flush 시키도록 하는 클래스입니다. PriorityQueue(우선순위 큐)를 이용했습니다. 
### 0205_유니티 연동 1~4
드디어 마지막 강의 입니다. 이번에는 유니티 엔진에 연동을 시작했습니다. 지금까지 만든 서버를 C#에서 자가구동하고 유니티 내부에서는 클라이언트로서 구동시켰습니다. 패킷도 본격적으로 실제 게임과 유사한 패킷을 만들어 테스트했습니다. 플레이어, 입장, 퇴장, 이동까지 총 네 개의 패킷을 송수신했으며 이번에는 콘솔로 로그만 찍히는게 아닌 유니티 에디터에서 테스트 실린더가 실제로 움직이는 작업까지 했습니다. 물론 단순하게 좌표 숫자만 랜덤으로 배치했을뿐이지만 굉장히 신선한 경헙이었습니다. 저번 시간까지만 해도 과연 이렇게 해서 실제 게임에서 적용이 될까? 싶었었는데 오늘 그 의문이 풀렸습니다.   
  
### 느낀 점
서버 프로그래밍 이라는게 게임 개발에 있어서 빠질 수 없는 요소이기 때문에 막연히 언젠간 배우겠지 하면서 미뤄왔었는데 막상 배우게 되니까 생각했던것보다 어렵지 않은데? 라고 생각했고 클라만 작업하면서 부족했던 코딩 능력이 조금 트이는 느낌이 들었습니다. 배운 점이 되게 많았습니다. 얕게 알고있던 직렬화에 대한 부분도 조금 확신이 생겼고 평소에 잘 쓰지 않던 자료구조에 대해서도 이해하기 쉬워졌습니다. 또 batchfile이 어떤 식으로 사용되는지 배웠습니다. 그리고 프로젝트를 라이브러리화 하는 방법에 대해서도 알게되었습니다. 강의를 들으면서 어려웠던 점은 코딩의 흐름을 쫓아가기가 조금 버거웠습니다. 처음에는 잘 따라가다가 후반부에 클래스들이 많아지기 시작하면서 조금 힘들었습니다. 오류가 났는데 디버깅하느라 한 두시간을 클래스 사이를 헤맸던 적도 있었습니다. 결론적으로 저에게는 굉장히 좋은 경험이었으며 또 다음에는 무엇을 배워야할지에 대한 감이 잡혔습니다.

## 자주 사용한 라이브러리
1) *BitConverter* (패킷을 전송시킬 때 사용) 
2) *Text.Encoding* (문자열을 직렬화 할 때 사용)  
3) *Threading* (멀티쓰레드 작업할 때 사용)
4) *Net* (네트워크 작업할 때 사용)  
5) *Net.Socket* (네트워크 소켓 프로그래밍 할 때 사용)  
